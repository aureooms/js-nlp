<!DOCTYPE html><html lang="en"><head><title>stemming/porter</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="stemming/porter"><meta name="groc-project-path" content="js/src/stemming/porter.js"><meta name="groc-github-url" content="https://github.com/aureooms/js-nlp"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/aureooms/js-nlp/blob/master/js/src/stemming/porter.js">js/src/stemming/porter.js</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>Imported from <a href="http://tartarus.org/martin/PorterStemmer/c.txt">http://tartarus.org/martin/PorterStemmer/c.txt</a>. All comments
below are from the original version in ANSI C.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is the Porter stemming algorithm, coded up in ANSI C by the
   author. It may be be regarded as canonical, in that it follows the
   algorithm presented in</p>
<p>   Porter, 1980, An algorithm for suffix stripping, Program, Vol. 14,
   no. 3, pp 130-137,</p>
<p>   only differing from it at the points marked --DEPARTURE-- below.</p>
<p>   See also <a href="http://www.tartarus.org/~martin/PorterStemmer">http://www.tartarus.org/~martin/PorterStemmer</a></p>
<p>   The algorithm as described in the paper could be exactly replicated
   by adjusting the points of DEPARTURE, but this is barely necessary,
   because (a) the points of DEPARTURE are definitely improvements, and
   (b) no encoding of the Porter stemmer I have seen is anything like
   as exact as this version, even with the points of DEPARTURE!</p>
<p>   You can compile it on Unix with &#39;gcc -O3 -o stem stem.c&#39; after which
   &#39;stem&#39; takes a list of inputs and sends the stemmed equivalent to
   stdout.</p>
<p>   The algorithm as encoded here is particularly fast.</p>
<p>   Release 1: was many years ago
   Release 2: 11 Apr 2013
       fixes a bug noted by Matt Patenaude <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#109;&#97;&#116;&#x74;&#64;&#109;&#97;&#x74;&#x74;&#x70;&#x61;&#x74;&#x65;&#110;&#x61;&#117;&#x64;&#101;&#46;&#x63;&#111;&#109;">&#109;&#97;&#116;&#x74;&#64;&#109;&#97;&#x74;&#x74;&#x70;&#x61;&#x74;&#x65;&#110;&#x61;&#117;&#x64;&#101;&#46;&#x63;&#111;&#109;</a>,</p>
<pre><code>   case &#39;o&#39;: if (ends(&quot;\03&quot; &quot;ion&quot;) &amp;&amp; (b[j] == &#39;s&#39; || b[j] == &#39;t&#39;)) break;
       ==&gt;
   case &#39;o&#39;: if (ends(&quot;\03&quot; &quot;ion&quot;) &amp;&amp; j &gt;= k0 &amp;&amp; (b[j] == &#39;s&#39; || b[j] == &#39;t&#39;)) break;

   to avoid accessing b[k0-1] when the word in b is &quot;ion&quot;.</code></pre>
<p>   Release 3: 25 Mar 2014
       fixes a similar bug noted by Klemens Baum <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#107;&#108;&#101;&#x6d;&#101;&#110;&#115;&#98;&#97;&#117;&#x6d;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;">&#107;&#108;&#101;&#x6d;&#101;&#110;&#115;&#98;&#97;&#117;&#x6d;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;</a>,
       that if step1ab leaves a one letter result (ied -&gt; i, aing -&gt; a etc),
       step2 and step4 access the byte before the first letter. So we skip
       steps after step1ab unless k &gt; k0.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The main part of the stemming algorithm starts here. b is a buffer
   holding a word to be stemmed. The letters are in b[k0], b[k0+1] ...
   ending at b[k]. In fact k0 = 0 in this demo program. k is readjusted
   downwards as the stemming progresses. Zero termination is not in fact
   used in the algorithm.</p>
<p>   Note that only lower case sequences are stemmed. Forcing to lower case
   should be done before stem(...) is called.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> porter = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( p , pi , pj )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>buffer for word to be stemmed</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> b ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>j is a general offset into the string</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> k , k0 , j ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>cons(i) is true &lt;=&gt; b[i] is a consonant.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> cons = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( i )</span> {</span>
	<span class="hljs-keyword">switch</span> ( b[i] ) {
		<span class="hljs-keyword">case</span> <span class="hljs-string">'a'</span> : <span class="hljs-keyword">case</span> <span class="hljs-string">'e'</span> : <span class="hljs-keyword">case</span> <span class="hljs-string">'i'</span> : <span class="hljs-keyword">case</span> <span class="hljs-string">'o'</span> : <span class="hljs-keyword">case</span> <span class="hljs-string">'u'</span> : <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> ;
		<span class="hljs-keyword">case</span> <span class="hljs-string">'y'</span> : <span class="hljs-keyword">return</span> ( i === k0 ) ? <span class="hljs-literal">true</span> : !cons( i - <span class="hljs-number">1</span> ) ;
		<span class="hljs-keyword">default</span> : <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> ;
	}
} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>m() measures the number of consonant sequences between k0 and j. if c is
a consonant sequence and v a vowel sequence, and &lt;..&gt; indicates arbitrary
presence,</p>
<pre><code>&lt;c&gt;&lt;v&gt;       gives 0
&lt;c&gt;vc&lt;v&gt;     gives 1
&lt;c&gt;vcvc&lt;v&gt;   gives 2
&lt;c&gt;vcvcvc&lt;v&gt; gives 3
....</code></pre></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> m = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( )</span> {</span>

	<span class="hljs-keyword">var</span> i , n ;

	n = <span class="hljs-number">0</span> ;
	i = k0 ;

	<span class="hljs-keyword">while</span> ( <span class="hljs-literal">true</span> ) {
		<span class="hljs-keyword">if</span> ( i &gt; j ) <span class="hljs-keyword">return</span> n ;
		<span class="hljs-keyword">if</span> ( !cons( i ) ) <span class="hljs-keyword">break</span> ;
		++i ;
   }

   ++i ;
   <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)
   {  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)
      {  <span class="hljs-keyword">if</span> (i &gt; j) <span class="hljs-keyword">return</span> n;
            <span class="hljs-keyword">if</span> (cons(i)) <span class="hljs-keyword">break</span>;
            i++;
      }
      i++;
      n++;
      <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)
      {  <span class="hljs-keyword">if</span> (i &gt; j) <span class="hljs-keyword">return</span> n;
         <span class="hljs-keyword">if</span> (! cons(i)) <span class="hljs-keyword">break</span>;
         i++;
      }
      i++;
   }
} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>vowelinstem() is true &lt;=&gt; k0,...j contains a vowel</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> vowelinstem = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span>
{</span>  <span class="hljs-keyword">var</span> i; <span class="hljs-keyword">for</span> (i = k0; i &lt;= j; i++) <span class="hljs-keyword">if</span> (! cons(i)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>doublec(j) is true &lt;=&gt; j,(j-1) contain a double consonant.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> doublec = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( j )</span> {</span>
	<span class="hljs-keyword">if</span> (j &lt; k0+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
   <span class="hljs-keyword">if</span> (b[j] != b[j-<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
   <span class="hljs-keyword">return</span> cons(j);
} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>cvc(i) is true &lt;=&gt; i-2,i-1,i has the form consonant - vowel - consonant
and also if the second c is not w,x or y. this is used when trying to
restore an e at the end of a short word. e.g.</p>
<pre><code>cav(e), lov(e), hop(e), crim(e), but
snow, box, tray.</code></pre></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> cvc = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( i )</span>
{</span>  <span class="hljs-keyword">if</span> (i &lt; k0+<span class="hljs-number">2</span> || !cons(i) || cons(i-<span class="hljs-number">1</span>) || !cons(i-<span class="hljs-number">2</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
   {  <span class="hljs-keyword">var</span> ch = b[i];
      <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'w'</span> || ch == <span class="hljs-string">'x'</span> || ch == <span class="hljs-string">'y'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
   }
   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>memcmp in JavaScript</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> memcmp = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( a , ai , aj , b , bi )</span> {</span>

	<span class="hljs-keyword">for</span> ( ; ai &lt; aj ; ++ai , ++bi ) {
		<span class="hljs-keyword">if</span> ( a[ai] === b[bi] ) <span class="hljs-keyword">continue</span> ;
		<span class="hljs-keyword">return</span> a[ai] &lt; b[bi] ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span> ;
	}

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;

} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ends(s) is true &lt;=&gt; k0,...k ends with the string s.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> ends = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( s )</span> {</span>
	<span class="hljs-keyword">var</span> len = s.length ;
	<span class="hljs-keyword">if</span> ( s[len - <span class="hljs-number">1</span>] !== b[k] ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> ; <span class="hljs-comment">/* tiny speed-up */</span>
	<span class="hljs-keyword">if</span> ( len &gt; k - k0 + <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> ;
	<span class="hljs-keyword">if</span> ( memcmp( b , k - len + <span class="hljs-number">1</span> , k + <span class="hljs-number">1</span> , s , <span class="hljs-number">0</span> ) !== <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> ;
	j = k - len ;
	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> ;
} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>memmove in JavaScript. ( not exactly because it would require to copy
backwards in case a and b are the same array and bi &gt; ai but we don&#39;t need
that in our use case )</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> memmove = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( a , ai , aj , b , bi )</span> {</span>

	<span class="hljs-keyword">for</span> ( ; ai &lt; aj ; ++ai , ++bi ) {
		b[bi] = a[ai] ;
	}

} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>setto(s) sets (j+1),...k to the characters in the string s, readjusting k.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> setto = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( s )</span> {</span>
	<span class="hljs-keyword">var</span> len = s.length ;
	memmove( s , <span class="hljs-number">0</span> , len , b , j + <span class="hljs-number">1</span> ) ;
	k = j + len ;
} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>r(s) is used further down.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> r = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( s )</span> {</span>
	<span class="hljs-keyword">if</span> ( m( ) &gt; <span class="hljs-number">0</span> ) setto( s ) ;
} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>step1ab() gets rid of plurals and -ed or -ing. e.g.</p>
<pre><code> caresses  -&gt;  caress
 ponies    -&gt;  poni
 ties      -&gt;  ti
 caress    -&gt;  caress
 cats      -&gt;  cat

 feed      -&gt;  feed
 agreed    -&gt;  agree
 disabled  -&gt;  disable

 matting   -&gt;  mat
 mating    -&gt;  mate
 meeting   -&gt;  meet
 milling   -&gt;  mill
 messing   -&gt;  mess

 meetings  -&gt;  meet</code></pre></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> step1ab = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( )</span> {</span>
	<span class="hljs-keyword">var</span> ch ;
	<span class="hljs-keyword">if</span> (b[k] == <span class="hljs-string">'s'</span>)
	{  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"sses"</span>)) k -= <span class="hljs-number">2</span>; <span class="hljs-keyword">else</span>
	  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ies"</span>)) setto( <span class="hljs-string">"i"</span>); <span class="hljs-keyword">else</span>
	  <span class="hljs-keyword">if</span> (b[k-<span class="hljs-number">1</span>] != <span class="hljs-string">'s'</span>) k--;
	}
	<span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"eed"</span>)) { <span class="hljs-keyword">if</span> (m() &gt; <span class="hljs-number">0</span>) k--; } <span class="hljs-keyword">else</span>
	<span class="hljs-keyword">if</span> ((ends( <span class="hljs-string">"ed"</span>) || ends( <span class="hljs-string">"ing"</span>)) &amp;&amp; vowelinstem())
	{  k = j;
	  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"at"</span>)) setto( <span class="hljs-string">"ate"</span>); <span class="hljs-keyword">else</span>
	  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"bl"</span>)) setto( <span class="hljs-string">"ble"</span>); <span class="hljs-keyword">else</span>
	  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"iz"</span>)) setto( <span class="hljs-string">"ize"</span>); <span class="hljs-keyword">else</span>
	  <span class="hljs-keyword">if</span> (doublec(k))
	  {  k--;
		 {  ch = b[k];
			<span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'l'</span> || ch == <span class="hljs-string">'s'</span> || ch == <span class="hljs-string">'z'</span>) k++;
		 }
	  }
	  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m() == <span class="hljs-number">1</span> &amp;&amp; cvc(k)) setto( <span class="hljs-string">"e"</span>);
	}
} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>step1c() turns terminal y to i when there is another vowel in the stem.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> step1c = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( )</span> {</span>
	<span class="hljs-keyword">if</span> (ends(<span class="hljs-string">"y"</span>) &amp;&amp; vowelinstem()) b[k] = <span class="hljs-string">'i'</span>;
} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>step2() maps double suffices to single ones. so -ization ( = -ize plus
-ation) maps to -ize etc. note that the string before the suffix must give
m() &gt; 0.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> step2 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( )</span> {</span>
	<span class="hljs-keyword">switch</span> (b[k-<span class="hljs-number">1</span>]) {

		<span class="hljs-keyword">case</span> <span class="hljs-string">'a'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ational"</span>)) { r( <span class="hljs-string">"ate"</span>); <span class="hljs-keyword">break</span>; }
				  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"tional"</span>)) { r( <span class="hljs-string">"tion"</span>); <span class="hljs-keyword">break</span>; }
				  <span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-string">'c'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"enci"</span>)) { r( <span class="hljs-string">"ence"</span>); <span class="hljs-keyword">break</span>; }
				  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"anci"</span>)) { r( <span class="hljs-string">"ance"</span>); <span class="hljs-keyword">break</span>; }
				  <span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-string">'e'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"izer"</span>)) { r( <span class="hljs-string">"ize"</span>); <span class="hljs-keyword">break</span>; }
				  <span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-string">'l'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"bli"</span>)) { r( <span class="hljs-string">"ble"</span>); <span class="hljs-keyword">break</span>; } <span class="hljs-comment">/*-DEPARTURE-*/</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>To match the published algorithm, replace this line with
case &#39;l&#39;: if (ends(&quot;abli&quot;)) { r(&quot;able&quot;); break; } </p></div></div><div class="code"><div class="wrapper">				  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"alli"</span>)) { r( <span class="hljs-string">"al"</span>); <span class="hljs-keyword">break</span>; }
				  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"entli"</span>)) { r( <span class="hljs-string">"ent"</span>); <span class="hljs-keyword">break</span>; }
				  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"eli"</span>)) { r( <span class="hljs-string">"e"</span>); <span class="hljs-keyword">break</span>; }
				  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ousli"</span>)) { r( <span class="hljs-string">"ous"</span>); <span class="hljs-keyword">break</span>; }
				  <span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-string">'o'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ization"</span>)) { r( <span class="hljs-string">"ize"</span>); <span class="hljs-keyword">break</span>; }
				  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ation"</span>)) { r( <span class="hljs-string">"ate"</span>); <span class="hljs-keyword">break</span>; }
				  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ator"</span>)) { r( <span class="hljs-string">"ate"</span>); <span class="hljs-keyword">break</span>; }
				  <span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-string">'s'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"alism"</span>)) { r( <span class="hljs-string">"al"</span>); <span class="hljs-keyword">break</span>; }
				  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"iveness"</span>)) { r( <span class="hljs-string">"ive"</span>); <span class="hljs-keyword">break</span>; }
			  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"fulness"</span>)) { r( <span class="hljs-string">"ful"</span>); <span class="hljs-keyword">break</span>; }
			  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ousness"</span>)) { r( <span class="hljs-string">"ous"</span>); <span class="hljs-keyword">break</span>; }
			  <span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> <span class="hljs-string">'t'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"aliti"</span>)) { r( <span class="hljs-string">"al"</span>); <span class="hljs-keyword">break</span>; }
			  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"iviti"</span>)) { r( <span class="hljs-string">"ive"</span>); <span class="hljs-keyword">break</span>; }
			  <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"biliti"</span>)) { r( <span class="hljs-string">"ble"</span>); <span class="hljs-keyword">break</span>; }
			  <span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> <span class="hljs-string">'g'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"logi"</span>)) { r( <span class="hljs-string">"log"</span>); <span class="hljs-keyword">break</span>; } <span class="hljs-comment">/*-DEPARTURE-*/</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>To match the published algorithm, delete this line </p></div></div><div class="code"><div class="wrapper">	}

} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>step3() deals with -ic-, -full, -ness etc. similar strategy to step2.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> step3 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( )</span> {</span> <span class="hljs-keyword">switch</span> (b[k])
{
    <span class="hljs-keyword">case</span> <span class="hljs-string">'e'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"icate"</span>)) { r( <span class="hljs-string">"ic"</span>); <span class="hljs-keyword">break</span>; }
              <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ative"</span>)) { r( <span class="hljs-string">""</span>); <span class="hljs-keyword">break</span>; }
              <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"alize"</span>)) { r( <span class="hljs-string">"al"</span>); <span class="hljs-keyword">break</span>; }
              <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'i'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"iciti"</span>)) { r( <span class="hljs-string">"ic"</span>); <span class="hljs-keyword">break</span>; }
              <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'l'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ical"</span>)) { r( <span class="hljs-string">"ic"</span>); <span class="hljs-keyword">break</span>; }
              <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ful"</span>)) { r( <span class="hljs-string">""</span>); <span class="hljs-keyword">break</span>; }
              <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'s'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ness"</span>)) { r( <span class="hljs-string">""</span>); <span class="hljs-keyword">break</span>; }
              <span class="hljs-keyword">break</span>;
} };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>step4() takes off -ant, -ence etc., in context <c>vcvc<v>.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> step4 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span>
{</span>  <span class="hljs-keyword">switch</span> (b[k-<span class="hljs-number">1</span>])
    {  <span class="hljs-keyword">case</span> <span class="hljs-string">'a'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"al"</span>)) <span class="hljs-keyword">break</span>; <span class="hljs-keyword">return</span>;
       <span class="hljs-keyword">case</span> <span class="hljs-string">'c'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ance"</span>)) <span class="hljs-keyword">break</span>;
                 <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ence"</span>)) <span class="hljs-keyword">break</span>; <span class="hljs-keyword">return</span>;
       <span class="hljs-keyword">case</span> <span class="hljs-string">'e'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"er"</span>)) <span class="hljs-keyword">break</span>; <span class="hljs-keyword">return</span>;
       <span class="hljs-keyword">case</span> <span class="hljs-string">'i'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ic"</span>)) <span class="hljs-keyword">break</span>; <span class="hljs-keyword">return</span>;
       <span class="hljs-keyword">case</span> <span class="hljs-string">'l'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"able"</span>)) <span class="hljs-keyword">break</span>;
                 <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ible"</span>)) <span class="hljs-keyword">break</span>; <span class="hljs-keyword">return</span>;
       <span class="hljs-keyword">case</span> <span class="hljs-string">'n'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ant"</span>)) <span class="hljs-keyword">break</span>;
                 <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ement"</span>)) <span class="hljs-keyword">break</span>;
                 <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ment"</span>)) <span class="hljs-keyword">break</span>;
                 <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ent"</span>)) <span class="hljs-keyword">break</span>; <span class="hljs-keyword">return</span>;
       <span class="hljs-keyword">case</span> <span class="hljs-string">'o'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ion"</span>) &amp;&amp; j &gt;= k0 &amp;&amp; (b[j] == <span class="hljs-string">'s'</span> || b[j] == <span class="hljs-string">'t'</span>)) <span class="hljs-keyword">break</span>;
                 <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ou"</span>)) <span class="hljs-keyword">break</span>; <span class="hljs-keyword">return</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>takes care of -ous </p></div></div><div class="code"><div class="wrapper">       <span class="hljs-keyword">case</span> <span class="hljs-string">'s'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ism"</span>)) <span class="hljs-keyword">break</span>; <span class="hljs-keyword">return</span>;
       <span class="hljs-keyword">case</span> <span class="hljs-string">'t'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ate"</span>)) <span class="hljs-keyword">break</span>;
                 <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"iti"</span>)) <span class="hljs-keyword">break</span>; <span class="hljs-keyword">return</span>;
       <span class="hljs-keyword">case</span> <span class="hljs-string">'u'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ous"</span>)) <span class="hljs-keyword">break</span>; <span class="hljs-keyword">return</span>;
       <span class="hljs-keyword">case</span> <span class="hljs-string">'v'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ive"</span>)) <span class="hljs-keyword">break</span>; <span class="hljs-keyword">return</span>;
       <span class="hljs-keyword">case</span> <span class="hljs-string">'z'</span>: <span class="hljs-keyword">if</span> (ends( <span class="hljs-string">"ize"</span>)) <span class="hljs-keyword">break</span>; <span class="hljs-keyword">return</span>;
       <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (m() &gt; <span class="hljs-number">1</span>) k = j;
} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>step5() removes a final -e if m() &gt; 1, and changes -ll to -l if m() &gt; 1.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> step5 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span>
{</span>  j = k;
   <span class="hljs-keyword">if</span> (b[k] == <span class="hljs-string">'e'</span>)
   {  <span class="hljs-keyword">var</span> a = m();
      <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">1</span> || a == <span class="hljs-number">1</span> &amp;&amp; !cvc(k-<span class="hljs-number">1</span>)) k--;
   }
   <span class="hljs-keyword">if</span> (b[k] == <span class="hljs-string">'l'</span> &amp;&amp; doublec(k) &amp;&amp; m() &gt; <span class="hljs-number">1</span>) k--;
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In stem(p,i,j), p is a char pointer, and the string to be stemmed is from
p[i] to p[j] inclusive. Typically i is zero and j is the offset to the last
character of a string, (p[j+1] == &#39;\0&#39;). The stemmer adjusts the
characters p[i] ... p[j] and returns the new end-point of the string, k.
Stemming never increases word length, so i &lt;= k &lt;= j. To turn the stemmer
into a module, declare &#39;stem&#39; as extern, and delete the remainder of this
file.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> stem = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( p , i , j )</span>
{</span>  b = p; k = j; k0 = i; <span class="hljs-comment">/* copy the parameters into statics */</span>
   <span class="hljs-keyword">if</span> (k &lt;= k0+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> k; <span class="hljs-comment">/*-DEPARTURE-*/</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>With this line, strings of length 1 or 2 don&#39;t go through the
   stemming process, although no mention is made of this in the
   published algorithm. Remove the line to match the published
   algorithm. </p></div></div><div class="code"><div class="wrapper">   step1ab();
   <span class="hljs-keyword">if</span> (k &gt; k0) {
       step1c(); step2(); step3(); step4(); step5();
   }
   <span class="hljs-keyword">return</span> k;
} ;

	<span class="hljs-keyword">return</span> stem( p , pi , pj - <span class="hljs-number">1</span> ) ;

} ;

exports.porter = porter ;</div></div></div></div></body></html>